<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Máquina virtual v1: src/mem_reg_io.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Máquina virtual v1
   </div>
   <div id="projectbrief">por Mateo Vazquez Baccaro y Valentina Acevedo</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('mem__reg__io_8c.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">mem_reg_io.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;<a class="el" href="mem__reg__io_8h_source.html">mem_reg_io.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="constantes_8h_source.html">constantes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="utils_8h_source.html">utils.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa010f44596d0fa5c3d4dce05a82687bb" id="r_aa010f44596d0fa5c3d4dce05a82687bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa010f44596d0fa5c3d4dce05a82687bb">cargarLAR</a> (int dirLogica, int registros[])</td></tr>
<tr class="memdesc:aa010f44596d0fa5c3d4dce05a82687bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carga en el LAR una dirección lógica.  <br /></td></tr>
<tr class="memitem:a778e4d867cd66ddf146858a366f4ad7b" id="r_a778e4d867cd66ddf146858a366f4ad7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a778e4d867cd66ddf146858a366f4ad7b">verificarIndiceSegmento</a> (int indiceSegmento, int tablaSegmentos[])</td></tr>
<tr class="memdesc:a778e4d867cd66ddf146858a366f4ad7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifica el índice usado para acceder a la tabla de segmentos.  <br /></td></tr>
<tr class="memitem:a99cf75399d343c71fff04fe960c2a7cd" id="r_a99cf75399d343c71fff04fe960c2a7cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99cf75399d343c71fff04fe960c2a7cd">cargarMAR</a> (int cantBytes, int registros[], int tablaSegmentos[])</td></tr>
<tr class="memdesc:a99cf75399d343c71fff04fe960c2a7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pone en el MAR los datos necesarios o termina el porgrama si son incorrectos.  <br /></td></tr>
<tr class="memitem:ac9d4b807b38dddb8abc7edf82b388550" id="r_ac9d4b807b38dddb8abc7edf82b388550"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9d4b807b38dddb8abc7edf82b388550">leerMemoria</a> (char memoria[], int registros[])</td></tr>
<tr class="memdesc:ac9d4b807b38dddb8abc7edf82b388550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pone en MBR un valor leído de memoria.  <br /></td></tr>
<tr class="memitem:a44997b88e824e02b6294b66cb0996487" id="r_a44997b88e824e02b6294b66cb0996487"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44997b88e824e02b6294b66cb0996487">cargarMBR</a> (int registros[], int valor)</td></tr>
<tr class="memdesc:a44997b88e824e02b6294b66cb0996487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pone en MBR un valor.  <br /></td></tr>
<tr class="memitem:a41ea255192acabf6dd7f780121b37f14" id="r_a41ea255192acabf6dd7f780121b37f14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41ea255192acabf6dd7f780121b37f14">escribirMemoria</a> (char memoria[], int registros[], int tablaSegmentos[])</td></tr>
<tr class="memdesc:a41ea255192acabf6dd7f780121b37f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pone en las celdas de memoria un valor guardado en MBR.  <br /></td></tr>
<tr class="memitem:a63487f3a7043da9bc09e1b74f573360f" id="r_a63487f3a7043da9bc09e1b74f573360f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63487f3a7043da9bc09e1b74f573360f">store</a> (char memoria[], int registros[], int tablaSegmentos[], int dirLogica, int cantBytes, int valor)</td></tr>
<tr class="memdesc:a63487f3a7043da9bc09e1b74f573360f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoca las funciones necesarias para escribir en memoria en el orden correcto.  <br /></td></tr>
<tr class="memitem:a142a0be58eacd01a390d94bf02df0507" id="r_a142a0be58eacd01a390d94bf02df0507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a142a0be58eacd01a390d94bf02df0507">verificarIndiceRegistro</a> (int indexReg)</td></tr>
<tr class="memdesc:a142a0be58eacd01a390d94bf02df0507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valida que un registro exista.  <br /></td></tr>
<tr class="memitem:af5259b4c87007a85287a673355ea4c1f" id="r_af5259b4c87007a85287a673355ea4c1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5259b4c87007a85287a673355ea4c1f">escribirMemoriaRegistro</a> (char memoria[], int registros[], int tablaSegmentos[], int operando, int valor)</td></tr>
<tr class="memdesc:af5259b4c87007a85287a673355ea4c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escribe en un registro o en memoria un valor.  <br /></td></tr>
<tr class="memitem:ac080994299f6d8112dd340dd502bad95" id="r_ac080994299f6d8112dd340dd502bad95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac080994299f6d8112dd340dd502bad95">OperandotoInmediato</a> (int operando, char memoria[], int registros[], int tablaSegmentos[])</td></tr>
<tr class="memdesc:ac080994299f6d8112dd340dd502bad95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el valor de un operando.  <br /></td></tr>
<tr class="memitem:aa79c8d366a3dd450a0101838665a3e20" id="r_aa79c8d366a3dd450a0101838665a3e20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa79c8d366a3dd450a0101838665a3e20">fetch</a> (char memoria[], int registros[], int tablaSegmentos[], int dirLogica, int cantBytes)</td></tr>
<tr class="memdesc:aa79c8d366a3dd450a0101838665a3e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoca las funciones necesarias para leer de memoria en el orden correcto.  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="aa010f44596d0fa5c3d4dce05a82687bb" name="aa010f44596d0fa5c3d4dce05a82687bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa010f44596d0fa5c3d4dce05a82687bb">&#9670;&#160;</a></span>cargarLAR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cargarLAR </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dirLogica</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>registros</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carga en el LAR una dirección lógica. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirLogica</td><td></td></tr>
    <tr><td class="paramname">registros</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99cf75399d343c71fff04fe960c2a7cd" name="a99cf75399d343c71fff04fe960c2a7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cf75399d343c71fff04fe960c2a7cd">&#9670;&#160;</a></span>cargarMAR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cargarMAR </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cantBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>registros</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tablaSegmentos</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pone en el MAR los datos necesarios o termina el porgrama si son incorrectos. </p>
<p>Crea la dirección física a partir de la dirección lógica en LAR. Si la dirección base del segmento apuntado por los primeros 2 bytes de la dirección lógica es menor o igual a la dirección física y el límite de acceso es menor al límite del segmento, en los 2 bytes más significativos de MAR irá la cantidad de bytes a leer/escribir y en los otros 2 irá la dirección física. De no cumplirse, termina el programa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cantBytes</td><td>Cantidad de bytes a leer/escribir en memoria. </td></tr>
    <tr><td class="paramname">registros</td><td></td></tr>
    <tr><td class="paramname">tablaSegmentos</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>LAR debe tener algún valor. </dd>
<dd>
cantBytes debe ser menor o igual a 4. </dd></dl>

</div>
</div>
<a id="a44997b88e824e02b6294b66cb0996487" name="a44997b88e824e02b6294b66cb0996487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44997b88e824e02b6294b66cb0996487">&#9670;&#160;</a></span>cargarMBR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cargarMBR </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>registros</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>valor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pone en MBR un valor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registros</td><td></td></tr>
    <tr><td class="paramname">valor</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a63487f3a7043da9bc09e1b74f573360f" title="Invoca las funciones necesarias para escribir en memoria en el orden correcto.">store()</a> </dd></dl>

</div>
</div>
<a id="a41ea255192acabf6dd7f780121b37f14" name="a41ea255192acabf6dd7f780121b37f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ea255192acabf6dd7f780121b37f14">&#9670;&#160;</a></span>escribirMemoria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void escribirMemoria </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>memoria</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>registros</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tablaSegmentos</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pone en las celdas de memoria un valor guardado en MBR. </p>
<p>Extrae la cantidad de bytes a leer y la dirección física de MAR. Guarda byte por byte en las celdas de memoria con la representación big-endian. El proceso de guardado es el siguiente: -Mueve hacia la izquierda el valor en MBR, dejando el byte a guardar en el más significativo. -Lo baja a los 8 bits más bajos. -Lo asigna a la celda de memoria correspondiente y como esta es char, solamente se queda con los 8 bits menos significativos del resultado de los desplazamientos. Es decir, no importa si se propagaron 1s en el proceso.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoria</td><td></td></tr>
    <tr><td class="paramname">registros</td><td></td></tr>
    <tr><td class="paramname">tablaSegmentos</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>En MAR debe haber en los 2 bytes más significativos la cantidad de bytes a leer y en los otros 2 una dirección física válida. </dd>
<dd>
En MBR debe haber un valor. </dd></dl>

</div>
</div>
<a id="af5259b4c87007a85287a673355ea4c1f" name="af5259b4c87007a85287a673355ea4c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5259b4c87007a85287a673355ea4c1f">&#9670;&#160;</a></span>escribirMemoriaRegistro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void escribirMemoriaRegistro </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>memoria</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>registros</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tablaSegmentos</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>operando</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>valor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escribe en un registro o en memoria un valor. </p>
<p>Extrae el tipo de operando y el resto de los datos (registro, offset) del operando. Realiza distintas instrucciones de escritura de acuerdo al tipo de operando. Si es de memoria, controla que la suma del offset de la dirección lógica en el registro indicado por el operando y el offset del operando no superen los 2 bytes. Esto es para que no ocurra un overflow y se "contamine" el puntero a la dirección del segmento en la dirección lógica. De no cumplirse esta condición, se termina el programa. Si se cumple, se arma la nueva dirección lógica y se invoca a <a class="el" href="#a63487f3a7043da9bc09e1b74f573360f" title="Invoca las funciones necesarias para escribir en memoria en el orden correcto.">store()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Quizás sea mejor hacer dicha validación en su propia función.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoria</td><td></td></tr>
    <tr><td class="paramname">registros</td><td></td></tr>
    <tr><td class="paramname">tablaSegmentos</td><td></td></tr>
    <tr><td class="paramname">operando</td><td>Valor del registro OP1 u OP2. </td></tr>
    <tr><td class="paramname">valor</td><td>Valor a escribir en registro o en memoria.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>El operando no es de tipo inmediato. </dd></dl>

</div>
</div>
<a id="aa79c8d366a3dd450a0101838665a3e20" name="aa79c8d366a3dd450a0101838665a3e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79c8d366a3dd450a0101838665a3e20">&#9670;&#160;</a></span>fetch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fetch </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>memoria</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>registros</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tablaSegmentos</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dirLogica</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cantBytes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoca las funciones necesarias para leer de memoria en el orden correcto. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoria</td><td></td></tr>
    <tr><td class="paramname">registros</td><td></td></tr>
    <tr><td class="paramname">tablaSegmentos</td><td></td></tr>
    <tr><td class="paramname">dirLogica</td><td>Dirección lógica derivada de un operando de memoria. </td></tr>
    <tr><td class="paramname">cantBytes</td><td>Cantidad de bytes/celdas a leer de memoria. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9d4b807b38dddb8abc7edf82b388550" name="ac9d4b807b38dddb8abc7edf82b388550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d4b807b38dddb8abc7edf82b388550">&#9670;&#160;</a></span>leerMemoria()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void leerMemoria </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>memoria</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>registros</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pone en MBR un valor leído de memoria. </p>
<p>Extrae la cantidad de bytes a leer y la dirección física de MAR. Utiliza una variable auxiliar inicializada en 0 con la cual, mediante corrimientos y la operación OR con cada celda de memoria, convierte lo guardado en varias celdas de memoria a un valor int. Se asegura de restaurar el signo del número leído. Al final, lo guarda en MBR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoria</td><td></td></tr>
    <tr><td class="paramname">registros</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>En MAR debe haber en los 2 bytes más significativos la cantidad de bytes a leer y en los otros 2 una dirección física válida. </dd></dl>

</div>
</div>
<a id="ac080994299f6d8112dd340dd502bad95" name="ac080994299f6d8112dd340dd502bad95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac080994299f6d8112dd340dd502bad95">&#9670;&#160;</a></span>OperandotoInmediato()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OperandotoInmediato </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>operando</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>memoria</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>registros</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tablaSegmentos</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el valor de un operando. </p>
<dl class="section warning"><dt>Warning</dt><dd>Cuando el operando es de memoria, no verifica que no haya overflow con el offset, algo que sí se hace en <a class="el" href="#af5259b4c87007a85287a673355ea4c1f" title="Escribe en un registro o en memoria un valor.">escribirMemoriaRegistro()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af5259b4c87007a85287a673355ea4c1f" title="Escribe en un registro o en memoria un valor.">escribirMemoriaRegistro()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operando</td><td>Valor en OP1 u OP2. </td></tr>
    <tr><td class="paramname">memoria</td><td></td></tr>
    <tr><td class="paramname">registros</td><td></td></tr>
    <tr><td class="paramname">tablaSegmentos</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Valor del operando. </dd></dl>

</div>
</div>
<a id="a63487f3a7043da9bc09e1b74f573360f" name="a63487f3a7043da9bc09e1b74f573360f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63487f3a7043da9bc09e1b74f573360f">&#9670;&#160;</a></span>store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void store </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>memoria</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>registros</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tablaSegmentos</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dirLogica</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cantBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>valor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoca las funciones necesarias para escribir en memoria en el orden correcto. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoria</td><td></td></tr>
    <tr><td class="paramname">registros</td><td></td></tr>
    <tr><td class="paramname">tablaSegmentos</td><td></td></tr>
    <tr><td class="paramname">dirLogica</td><td>Dirección lógica derivada de un operando de memoria. </td></tr>
    <tr><td class="paramname">cantBytes</td><td>Cantidad de bytes/celdas a escribir en memoria. </td></tr>
    <tr><td class="paramname">valor</td><td>Valor a escribir en memoria.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>cantBytes debe ser menor o igual a 4. </dd></dl>

</div>
</div>
<a id="a142a0be58eacd01a390d94bf02df0507" name="a142a0be58eacd01a390d94bf02df0507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142a0be58eacd01a390d94bf02df0507">&#9670;&#160;</a></span>verificarIndiceRegistro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void verificarIndiceRegistro </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>indexReg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Valida que un registro exista. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexReg</td><td>Índice de un registro. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a778e4d867cd66ddf146858a366f4ad7b" name="a778e4d867cd66ddf146858a366f4ad7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778e4d867cd66ddf146858a366f4ad7b">&#9670;&#160;</a></span>verificarIndiceSegmento()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void verificarIndiceSegmento </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>indiceSegmento</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tablaSegmentos</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifica el índice usado para acceder a la tabla de segmentos. </p>
<p>Verifica que el índice sea menor a 8 y que la tabla tenga un valor válido en esa posición. Es decir, que tenga un valor distinto a -1. Si el índice no es válido, termina el programa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indiceSegmento</td><td>Los 2 bytes más significativos de una dirección lógica. </td></tr>
    <tr><td class="paramname">tablaSegmentos</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>La tabla de segmentos debe estar inicializada con -1 o un valor válido. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a href="mem__reg__io_8c.html">mem_reg_io.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
